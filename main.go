package main

import (
	"cloud.google.com/go/firestore"
	"context"
	"encoding/json"
	// "fmt" // Removed as no longer used
	"html/template"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	// "sync" // No longer needed for in-memory map, Firestore handles concurrency
	"time"

	"google.golang.org/api/iterator"
)

const projectID = "utba-swarmmap"
const reportsCollection = "swarms"

// SwarmReport defines the structure for a swarm report (matches Firestore document)
type SwarmReport struct {
	ID                    string    `firestore:"-" json:"id"` // Firestore doc ID, not stored in doc fields
	Latitude              float64   `firestore:"latitude" json:"latitude"`
	Longitude             float64   `firestore:"longitude" json:"longitude"`
	Description           string    `firestore:"description" json:"description"`
	Status                string    `firestore:"status" json:"status"`
	ReportedTimestamp     time.Time `firestore:"reportedTimestamp" json:"reportedTimestamp"`
	VerificationTimestamp time.Time `firestore:"verificationTimestamp,omitempty" json:"verificationTimestamp,omitempty"`
	CapturedTimestamp     time.Time `firestore:"capturedTimestamp,omitempty" json:"capturedTimestamp,omitempty"`
	LastUpdatedTimestamp  time.Time `firestore:"lastUpdatedTimestamp" json:"lastUpdatedTimestamp"`
	ReportedMediaURLs     []string  `firestore:"reportedMediaURLs,omitempty" json:"reportedMediaURLs,omitempty"`
	CapturedMediaURLs     []string  `firestore:"capturedMediaURLs,omitempty" json:"capturedMediaURLs,omitempty"`
	BeekeeperNotes        string    `firestore:"beekeeperNotes,omitempty" json:"beekeeperNotes,omitempty"`
	DisplayStatus         string    `firestore:"-" json:"displayStatus,omitempty"` // Transient, for frontend logic
}

// Firestore client (global)
var firestoreClient *firestore.Client

// Template cache
var templates *template.Template

// No longer need in-memory store or ID generation; Firestore handles this.
// var (
// 	reports   = make(map[string]SwarmReport)
// 	reportsMu sync.RWMutex
// 	nextReportID int64 = 0
// 	reportIDMu sync.Mutex
// )
// func generateReportID() string { ... }

func main() {
	ctx := context.Background()
	var err error

	// Initialize Firestore client
	firestoreClient, err = firestore.NewClient(ctx, projectID)
	if err != nil {
		log.Fatalf("Failed to create Firestore client: %v", err)
	}
	defer firestoreClient.Close()

	// Parse templates
	templates, err = template.ParseGlob(filepath.Join("templates", "*.html"))
	if err != nil {
		log.Fatalf("Error parsing templates: %v", err)
	}

	http.HandleFunc("/", indexHandler)
	http.HandleFunc("/report_swarm", reportSwarmHandler)
	http.HandleFunc("/get_swarms", getSwarmsHandler)
	http.HandleFunc("/update_swarm_status", updateSwarmStatusHandler)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	log.Printf("Listening on port %s", port)
	if err := http.ListenAndServe(":"+port, nil); err != nil {
		log.Fatal(err)
	}
}

func indexHandler(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		http.NotFound(w, r)
		return
	}
	err := templates.ExecuteTemplate(w, "index.html", nil)
	if err != nil {
		log.Printf("Error executing template: %v", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
	}
}

func reportSwarmHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST method is allowed", http.StatusMethodNotAllowed)
		return
	}
	ctx := context.Background()

	err := r.ParseMultipartForm(10 << 20) 
	if err != nil {
		log.Printf("Error parsing multipart form: %v", err)
		http.Error(w, "Error parsing form data", http.StatusBadRequest)
		return
	}

	latStr := r.FormValue("latitude")
	lonStr := r.FormValue("longitude")
	description := r.FormValue("description")

	latitude, err := strconv.ParseFloat(latStr, 64)
	if err != nil {
		log.Printf("Error parsing latitude: %v", err)
		http.Error(w, "Invalid latitude value", http.StatusBadRequest)
		return
	}
	longitude, err := strconv.ParseFloat(lonStr, 64)
	if err != nil {
		log.Printf("Error parsing longitude: %v", err)
		http.Error(w, "Invalid longitude value", http.StatusBadRequest)
		return
	}

	currentTime := time.Now().UTC() // Use UTC for consistency
	reportData := SwarmReport{
		// ID will be auto-generated by Firestore or we can set it
		Latitude:            latitude,
		Longitude:           longitude,
		Description:         description,
		Status:              "Reported",
		ReportedTimestamp:   currentTime,
		LastUpdatedTimestamp: currentTime,
		ReportedMediaURLs:   []string{},
		CapturedMediaURLs:   []string{},
	}

	// TODO: Handle file upload for media to GCS and store URLs in ReportedMediaURLs

	docRef, _, err := firestoreClient.Collection(reportsCollection).Add(ctx, reportData)
	if err != nil {
		log.Printf("Failed to add report to Firestore: %v", err)
		http.Error(w, "Error saving report", http.StatusInternalServerError)
		return
	}
	reportData.ID = docRef.ID // Get the auto-generated ID

	log.Printf("Received and stored new swarm report with ID %s: %+v", reportData.ID, reportData)
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(reportData)
}

func getSwarmsHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Only GET method is allowed", http.StatusMethodNotAllowed)
		return
	}
	ctx := context.Background()
	var currentReports []SwarmReport

	iter := firestoreClient.Collection(reportsCollection).Documents(ctx)
	for {
		doc, err := iter.Next()
		if err == iterator.Done {
			break
		}
		if err != nil {
			log.Printf("Failed to iterate Firestore documents: %v", err)
			http.Error(w, "Error fetching reports", http.StatusInternalServerError)
			return
		}

		var report SwarmReport
		if err := doc.DataTo(&report); err != nil {
			log.Printf("Failed to convert Firestore document to SwarmReport: %v", err)
			// Optionally skip this report or return error
			continue
		}
		report.ID = doc.Ref.ID // Set the document ID

		// Dynamic DisplayStatus logic
		report.DisplayStatus = report.Status
		if report.Status != "Captured" && time.Since(report.ReportedTimestamp).Hours() > 24*7 {
			report.DisplayStatus = "Archived"
		}
		currentReports = append(currentReports, report)
	}

	data, err := json.Marshal(currentReports)
	if err != nil {
		log.Printf("Error marshalling reports to JSON: %v", err)
		http.Error(w, "Internal Server Error", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.Write(data)
}

func updateSwarmStatusHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST method is allowed", http.StatusMethodNotAllowed)
		return
	}
	ctx := context.Background()

	var updateReq struct {
		ID             string `json:"id"`
		Status         string `json:"status"`
		BeekeeperNotes string `json:"beekeeperNotes"`
	}

	if err := json.NewDecoder(r.Body).Decode(&updateReq); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	if updateReq.ID == "" || updateReq.Status == "" {
		http.Error(w, "Missing id or status in request", http.StatusBadRequest)
		return
	}

	docRef := firestoreClient.Collection(reportsCollection).Doc(updateReq.ID)
	currentTime := time.Now().UTC()
	var updates []firestore.Update

	updates = append(updates, firestore.Update{Path: "status", Value: updateReq.Status})
	updates = append(updates, firestore.Update{Path: "lastUpdatedTimestamp", Value: currentTime})

	if updateReq.BeekeeperNotes != "" {
		updates = append(updates, firestore.Update{Path: "beekeeperNotes", Value: updateReq.BeekeeperNotes})
	}

	switch updateReq.Status {
	case "Verified":
		updates = append(updates, firestore.Update{Path: "verificationTimestamp", Value: currentTime})
	case "Captured":
		updates = append(updates, firestore.Update{Path: "capturedTimestamp", Value: currentTime})
		// TODO: Handle captured media uploads here or in a separate endpoint, update CapturedMediaURLs
	}

	_, err := docRef.Update(ctx, updates)
	if err != nil {
		log.Printf("Failed to update report %s in Firestore: %v", updateReq.ID, err)
		http.Error(w, "Error updating report", http.StatusInternalServerError)
		// Consider checking for errcodes.NotFound specifically
		return
	}

	// Fetch the updated document to return it
	dsnap, err := docRef.Get(ctx)
	if err != nil {
		log.Printf("Failed to fetch updated report %s from Firestore: %v", updateReq.ID, err)
		http.Error(w, "Error fetching updated report", http.StatusInternalServerError)
		return
	}
	var updatedReport SwarmReport
	if err := dsnap.DataTo(&updatedReport); err != nil {
		log.Printf("Failed to convert updated Firestore document: %v", err)
		http.Error(w, "Error processing updated report", http.StatusInternalServerError)
		return
	}
	updatedReport.ID = dsnap.Ref.ID

	log.Printf("Updated swarm report %s to status %s: %+v", updatedReport.ID, updatedReport.Status, updatedReport)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updatedReport)
} 