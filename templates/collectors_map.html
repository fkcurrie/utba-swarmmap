<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=yes">
    <title>Collector Swarm Map - UTBA</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="stylesheet" href="/static/css/style.css">
    <script>
        // Client-side authentication check (Standard for authenticated pages)
        async function checkAuth() {
            try {
                const response = await fetch('/auth', { cache: 'no-store' }); // Ensure fresh auth check
                if (!response.ok) throw new Error('Auth check failed with status: ' + response.status);
                const data = await response.json();
                if (!data.authenticated || !data.user) { // Check for user object as well
                    console.log('Collectors Map: Not authenticated or user data missing. Redirecting to login.');
                    window.location.href = '/login?returnUrl=' + encodeURIComponent(window.location.pathname);
                } else {
                    console.log('Collectors Map: Authenticated as', data.user.username, 'Role:', data.user.role);
                    // Update navbar with username if placeholder exists (optional enhancement)
                    const welcomeMsg = document.getElementById('welcomeMessage');
                    if (welcomeMsg) welcomeMsg.textContent = 'Welcome, ' + data.user.username;
                }
            } catch (error) {
                console.error('Collectors Map: Authentication check error:', error);
                alert('Critical authentication check error: ' + error.message + '. Redirecting to login.');
                window.location.href = '/login?returnUrl=' + encodeURIComponent(window.location.pathname);
            }
        }
        checkAuth();

        // Forceful client-side logout (Standard for authenticated pages)
        async function forceLogout() {
            alert('Logging out...');
            try {
                await fetch('/logout', { method: 'GET', headers: { 'Cache-Control': 'no-cache' } });
                localStorage.removeItem('publicUserSessionId'); // Clear just in case
                document.cookie = "session=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                alert('Redirecting to homepage...');
                window.location.href = '/?logout=' + Date.now();
            } catch (error) {
                console.error('Error during forceLogout:', error);
                alert('Error during logout. Redirecting manually...');
                window.location.href = '/?logout_fallback=' + Date.now();
            }
        }
    </script>
    <style>
        /* Map and marker styles are now handled directly via JavaScript for consistency */
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-md navbar-dark fixed-top">
        <a class="navbar-brand" href="/">UTBA Swarm Map (Public)</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item"><span id="welcomeMessage" class="navbar-text mr-3">Welcome, Collector!</span></li>
                <li class="nav-item"><a class="nav-link" href="/dashboard">Dashboard</a></li>
                <!-- Add links to admin pages if user has appropriate roles - this requires passing user role to template -->
                {{if .UserSessionData }} {{/* Placeholder for passing user data from Go handler */}}
                    {{if or (eq .UserSessionData.Role "collector_admin") (eq .UserSessionData.Role "site_admin")}}
                    <li class="nav-item"><a class="nav-link" href="/collector_admin">Collector Admin</a></li>
                    {{end}}
                    {{if eq .UserSessionData.Role "site_admin"}}
                    <li class="nav-item"><a class="nav-link" href="/admin">Site Admin</a></li>
                    {{end}}
                {{end}}
                <li class="nav-item"><a class="nav-link" href="#" onclick="forceLogout(); return false;">Logout</a></li>
            </ul>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <div class="col-md-12">
                <div id="map"></div>
            </div>
        </div>
        <div class="row mt-1 mb-3">
            <div class="col-md-12 text-center">
                <button id="reportSwarmBtn" class="btn btn-primary mr-2">Report Swarm at My Location</button>
                <button id="refreshMapBtn" class="btn btn-secondary mr-2">Clear & Refresh Map</button>
                <small class="text-muted"> (Or click on the map to report at a specific spot)</small>
            </div>
        </div>
        
        <!-- Pin Color Legend -->
        <div class="row mb-3">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-body py-2">
                        <h6 class="card-title mb-2">Pin Color Legend:</h6>
                        <div class="d-flex flex-wrap justify-content-center">
                            <span class="mr-3 mb-1">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: #ff0000; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); vertical-align: middle;"></span>
                                <small class="ml-1">Red = Reported (new)</small>
                            </span>
                            <span class="mr-3 mb-1">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: #ff69b4; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); vertical-align: middle;"></span>
                                <small class="ml-1">Pink = Verified</small>
                            </span>
                            <span class="mr-3 mb-1">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: #00ff00; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); vertical-align: middle;"></span>
                                <small class="ml-1">Green = Captured</small>
                            </span>
                            <span class="mr-3 mb-1">
                                <span style="display: inline-block; width: 20px; height: 20px; background-color: #0000ff; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3); vertical-align: middle;"></span>
                                <small class="ml-1">Blue = Archived (24h+)</small>
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Debug Section (can be removed later) -->
        <div class="row mb-3">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-body py-2">
                        <h6 class="card-title mb-2">Swarm Data (All - for Collectors):</h6>
                        <div id="debugSwarms" style="font-size: 12px; max-height: 150px; overflow-y: auto;">
                            <em>All swarm reports will appear here after loading.</em>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Report Swarm Modal -->
    <div class="modal fade" id="reportSwarmModal" tabindex="-1" role="dialog" aria-labelledby="reportSwarmModalLabel" aria-hidden="true">
        <div class="modal-dialog" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="reportSwarmModalLabel">Report Bee Swarm</h5>
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <form id="reportSwarmForm">
                        <div class="form-group">
                            <label for="description">Description (e.g., size of swarm, height from ground, on a tree branch)</label>
                            <textarea class="form-control" id="description" name="description" rows="3" required></textarea>
                        </div>
                        <div class="form-group">
                            <label for="intersection">Nearest Major Intersection</label>
                            <input type="text" class="form-control" id="intersection" name="intersection" placeholder="e.g., Yonge & Bloor" required>
                        </div>
                        
                        <!-- Contact Information Section -->
                        <div class="form-section mt-4 p-3 border rounded" style="background-color: #f8f9fa;">
                            <h6 class="mb-3">üìû Contact Information (Optional but Recommended)</h6>
                            <p class="small text-muted mb-3">Providing your contact details helps beekeepers reach you for additional information or to coordinate swarm collection.</p>
                            
                            <div class="form-group">
                                <label for="reporterName">Your Name</label>
                                <input type="text" class="form-control" id="reporterName" name="reporterName" placeholder="e.g., John Smith">
                            </div>
                            <div class="form-group">
                                <label for="reporterEmail">Email Address</label>
                                <input type="email" class="form-control" id="reporterEmail" name="reporterEmail" placeholder="e.g., john@example.com">
                            </div>
                            <div class="form-group">
                                <label for="reporterPhone">Phone Number</label>
                                <input type="tel" class="form-control" id="reporterPhone" name="reporterPhone" placeholder="e.g., (416) 555-0123">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="media">üì∏ Upload Photo(s) and/or Video(s) (Optional)</label>
                            <div class="file-upload-section">
                                <input type="file" class="form-control-file" id="media" name="media" accept="image/*,video/*" capture="environment" style="display: none;">
                                <button type="button" class="btn btn-outline-primary" id="addFileBtn">
                                    <i class="fas fa-plus"></i> Add Photo/Video
                                </button>
                                <small class="form-text text-muted">Supported: JPG, PNG, HEIC, MP4, MOV, AVI, 3GP (max 10MB each)</small>
                            </div>
                            
                            <!-- File management area -->
                            <div id="fileManagementArea" style="margin-top: 15px; display: none;">
                                <h6>Selected Files:</h6>
                                <div id="selectedFilesList" class="border rounded p-3" style="max-height: 300px; overflow-y: auto; background-color: #f8f9fa;">
                                    <!-- Selected files will be displayed here -->
                                </div>
                                <div class="mt-2 d-flex justify-content-between align-items-center">
                                    <small class="text-success">‚úì <span id="totalFileCount">0</span> file(s) ready to upload</small>
                                    <button type="button" class="btn btn-sm btn-outline-danger" id="clearAllFilesBtn">
                                        <i class="fas fa-trash"></i> Clear All
                                    </button>
                                </div>
                            </div>
                        </div>
                        <input type="hidden" id="latitude" name="latitude">
                        <input type="hidden" id="longitude" name="longitude">
                        <button type="submit" class="btn btn-primary">Submit Report</button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    
    <!-- TODO: Add a separate modal for UTBA members to update status -->

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.3/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

    <script>
        // Centralized color definitions for consistency between legend and map markers
        const SWARM_COLORS = {
            "Reported": "#ff0000",  // Red
            "Verified": "#ff69b4",  // Hot Pink  
            "Captured": "#00ff00",  // Lime Green
            "Archived": "#0000ff"   // Blue
        };

        const map = L.map('map').setView([43.6532, -79.3832], 12); // Default to Toronto
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        let userClickedMarker; 
        let currentLocationMarker; 
        let reportedSwarmMarkers = new Map(); 
        let _currentLocateUserDoPan = false; // Ensure this is defined for the workaround

        // Function to get nearest intersection using Nominatim
        async function getNearestIntersection(lat, lng) {
            try {
                // First try to get the road information
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`);
                const data = await response.json();
                
                if (data.address) {
                    // Try to construct an intersection if possible
                    const road = data.address.road || data.address.pedestrian || data.address.path;
                    const intersection = data.address.intersection;
                    
                    if (road && intersection) {
                        return `${road} & ${intersection}`;
                    } else if (road) {
                        // If no intersection found, try to get the nearest cross street
                        const crossStreetResponse = await fetch(
                            `https://nominatim.openstreetmap.org/search?format=json&q=${road} near ${lat},${lng}&limit=1`
                        );
                        const crossStreetData = await crossStreetResponse.json();
                        
                        if (crossStreetData.length > 0 && crossStreetData[0].display_name) {
                            const addressParts = crossStreetData[0].display_name.split(',');
                            // Try to find a cross street in the address parts
                            for (const part of addressParts) {
                                if (part.includes('&') || part.includes('and')) {
                                    return part.trim();
                                }
                            }
                        }
                        
                        // If no cross street found, return the road name
                        return road;
                    }
                }
                
                // Fallback to the full address if no road/intersection found
                return data.display_name || 'Unknown Location';
            } catch (error) {
                console.error('Error getting intersection:', error);
                return 'Intersection lookup failed';
            }
        }

        // Update the locateUser function to get intersection
        async function locateUser(doPan = false) {
            console.log('[Collectors Map - locateUser] Called with doPan:', doPan);
            _currentLocateUserDoPan = doPan;

            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(async function(position) {
                    console.log('[Collectors Map - locateUser callback] Geolocation success. _currentLocateUserDoPan value:', _currentLocateUserDoPan);
                    const userLatLng = [position.coords.latitude, position.coords.longitude];
                    
                    if (!map) {
                        console.error('[Collectors Map - locateUser callback] Map object is not initialized!');
                        if (_currentLocateUserDoPan) alert("Map error. Cannot proceed with report.");
                        return;
                    }

                    if (_currentLocateUserDoPan) { 
                        console.log('[Collectors Map - locateUser callback] Panning map to:', userLatLng);
                        map.setView(userLatLng, 15);
                        if (currentLocationMarker) {
                            currentLocationMarker.setLatLng(userLatLng);
                        } else {
                            currentLocationMarker = L.marker(userLatLng, {alt: 'Current Location'}).addTo(map).bindPopup("Reporting at your current location");
                        }
                        currentLocationMarker.openPopup();

                        const latInput = document.getElementById('latitude');
                        const lonInput = document.getElementById('longitude');
                        const intersectionInput = document.getElementById('intersection');
                        if (latInput) latInput.value = userLatLng[0];
                        if (lonInput) lonInput.value = userLatLng[1];
                        
                        try {
                            const intersection = await getNearestIntersection(position.coords.latitude, position.coords.longitude);
                            console.log('[Collectors Map - locateUser callback] Fetched intersection for report:', intersection);
                            if (intersectionInput) intersectionInput.value = intersection;
                        } catch (e) {
                            console.error('[Collectors Map - locateUser callback] Error getting intersection for report:', e);
                            if (intersectionInput) intersectionInput.value = 'Could not fetch intersection';
                        }
                        
                        if (reportSwarmModal) {
                            reportSwarmModal.show();
                        } else {
                            console.warn("Collectors map: Report swarm modal instance not found.");
                        }
                    } else {
                        console.log('[Collectors Map - locateUser callback] Not panning map. Geolocation received silently.');
                    }
                }, function(error) {
                    console.error("[Collectors Map - locateUser callback] Geolocation failed:", error.message);
                    if (_currentLocateUserDoPan) {
                        alert("Could not get your location. Error: " + error.message);
                    }
                }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
            } else {
                console.log("[Collectors Map - locateUser] Geolocation is not supported.");
                if (_currentLocateUserDoPan) {
                    alert("Geolocation is not supported by this browser.");
                }
            }
        }

        // Update the map click handler to get intersection
        map.on('click', async function(e) {
            if (userClickedMarker) {
                map.removeLayer(userClickedMarker);
            }
            userClickedMarker = L.marker(e.latlng).addTo(map).bindPopup("Chosen Swarm Location");
            const lat = e.latlng.lat;
            const lng = e.latlng.lng;
            document.getElementById('latitude').value = lat;
            document.getElementById('longitude').value = lng;

            // Get nearest intersection
            const intersection = await getNearestIntersection(lat, lng);
            document.getElementById('intersection').value = intersection;

            reportSwarmModal.show();
        });

        // Initialize on page load
        window.onload = function() {
            locateUser(); 
            fetchAndDisplaySwarms(); // Call for authenticated map
        };

        function getMarkerHTML(status) {
            const color = SWARM_COLORS[status] || SWARM_COLORS["Reported"]; // Default to red if unknown status
            console.log('getMarkerHTML called with status:', status, 'using color:', color);
            return `<div style="background-color: ${color}; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`;
        }

        async function fetchAndDisplaySwarms() {
            console.log('Collectors Map: Fetching all swarms (authenticated user).');
            try {
                // Authenticated users: fetch /get_swarms WITHOUT sessionId
                const response = await fetch('/get_swarms'); 
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const swarms = await response.json() || [];
                console.log('Collectors Map: Fetched all swarms:', swarms.length, swarms);

                const currentSwarmIDs = new Set(swarms.map(s => s.id));

                // Remove markers for swarms that no longer exist
                reportedSwarmMarkers.forEach((marker, id) => {
                    if (!currentSwarmIDs.has(id)) {
                        console.log('Removing marker for swarm:', id);
                        map.removeLayer(marker);
                        reportedSwarmMarkers.delete(id);
                    }
                });

                // Add or update markers for current swarms
                swarms.forEach(swarm => {
                    console.log('Processing swarm:', swarm.id, 'status:', swarm.status, 'displayStatus:', swarm.displayStatus, 'lat/lng:', swarm.latitude, swarm.longitude);
                    const markerStatus = swarm.displayStatus || swarm.status;
                    console.log('Marker will be colored as:', markerStatus);
                    const reportedTime = new Date(swarm.reportedTimestamp).toLocaleString('en-US', { timeZone: 'America/Toronto' });
                    
                    // Create popup content with optional image
                    let popupContent = `ID: ${swarm.id}<br>Status: ${swarm.status}<br>Display Status: ${swarm.displayStatus}<br>Reported: ${reportedTime}<br>${swarm.description || "Reported Swarm"}`;
                    
                    // Add first image if available
                    if (swarm.reportedMediaURLs && swarm.reportedMediaURLs.length > 0) {
                        const firstImageUrl = swarm.reportedMediaURLs[0];
                        // Check if it's an image (not video)
                        if (firstImageUrl.match(/\.(jpg|jpeg|png|gif|heic|heif)$/i)) {
                            popupContent += `<br><br><img src="${firstImageUrl}" style="max-width: 200px; max-height: 150px; object-fit: cover; border-radius: 4px;" alt="Swarm photo">`;
                        }
                    }

                    let existingMarker = reportedSwarmMarkers.get(swarm.id);

                    if (existingMarker) {
                        console.log('Updating existing marker for swarm:', swarm.id);
                        existingMarker.setLatLng([swarm.latitude, swarm.longitude]);
                        existingMarker.setPopupContent(popupContent);
                        // Update the marker icon with new styling
                        const markerHTML = getMarkerHTML(markerStatus);
                        console.log('Updated marker HTML:', markerHTML);
                        existingMarker.setIcon(L.divIcon({ 
                            className: '', // No CSS class needed
                            iconSize: [25, 41], 
                            iconAnchor: [12, 41],
                            html: markerHTML
                        }));
                    } else {
                        console.log('Creating new marker for swarm:', swarm.id, 'with status:', markerStatus);
                        const markerHTML = getMarkerHTML(markerStatus);
                        console.log('Generated marker HTML:', markerHTML);
                        const newMarker = L.marker([swarm.latitude, swarm.longitude], {
                            icon: L.divIcon({ 
                                className: '', // No CSS class needed
                                iconSize: [25, 41], 
                                iconAnchor: [12, 41],
                                html: markerHTML
                            })
                        }).addTo(map).bindPopup(popupContent);
                        reportedSwarmMarkers.set(swarm.id, newMarker);
                        console.log('Added marker to map for swarm:', swarm.id, 'should be colored:', markerStatus);
                    }
                });
                
                console.log('Total markers on map:', reportedSwarmMarkers.size);
                
                // Update debug section
                const debugDiv = document.getElementById('debugSwarms');
                if (debugDiv) {
                    let debugHTML = '<table class="table table-sm"><thead><tr><th>ID</th><th>Status</th><th>Display</th><th>Reported</th><th>Pin</th></tr></thead><tbody>';
                    swarms.forEach(swarm => {
                        const markerStatus = swarm.displayStatus || swarm.status;
                        const reportedTime = new Date(swarm.reportedTimestamp).toLocaleString('en-US', { timeZone: 'America/Toronto' });
                        const colorHex = SWARM_COLORS[markerStatus] || SWARM_COLORS["Reported"];
                        let colorName = 'Unknown';
                        switch(markerStatus) {
                            case 'Reported': colorName = 'Red'; break;
                            case 'Verified': colorName = 'Pink'; break;
                            case 'Captured': colorName = 'Green'; break;
                            case 'Archived': colorName = 'Blue'; break;
                        }
                        debugHTML += `<tr><td>${swarm.id.substring(0,8)}...</td><td>${swarm.status}</td><td>${swarm.displayStatus}</td><td>${reportedTime}</td><td><span style="color: ${colorHex}; font-weight: bold;">${colorName} (${colorHex})</span></td></tr>`;
                    });
                    debugHTML += '</tbody></table>';
                    debugDiv.innerHTML = debugHTML;
                }
            } catch (error) {
                console.error("Collectors Map: Could not fetch swarms:", error);
                alert("Collectors Map: Error loading swarms: " + error.message);
            }
        }

        const reportSwarmBtn = document.getElementById('reportSwarmBtn');
        const refreshMapBtn = document.getElementById('refreshMapBtn');
        const reportSwarmModalEl = document.getElementById('reportSwarmModal'); // Get element first
        const reportSwarmModal = reportSwarmModalEl ? new bootstrap.Modal(reportSwarmModalEl) : null; // Initialize if element exists
        const reportSwarmForm = document.getElementById('reportSwarmForm');
        const latitudeInput = document.getElementById('latitude');
        const longitudeInput = document.getElementById('longitude');
        const mediaInput = document.getElementById('media');
        const mediaPreview = document.getElementById('mediaPreview');

        if (reportSwarmBtn) {
            reportSwarmBtn.addEventListener('click', function() {
                locateUser(true);
            });
        }

        // Mobile detection and user experience improvements
        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
        }

        // File management system for incremental file selection
        let selectedFiles = []; // Array to store all selected files
        let fileIdCounter = 0;  // Counter for unique file IDs

        // Initialize file management system
        function initializeFileManagement() {
            const addFileBtn = document.getElementById('addFileBtn');
            const fileInput = document.getElementById('media');
            const clearAllBtn = document.getElementById('clearAllFilesBtn');

            // Handle "Add Photo/Video" button click
            addFileBtn.addEventListener('click', function() {
                fileInput.value = ''; // Clear previous selection
                fileInput.click();    // Trigger file selection dialog
            });

            // Handle file selection
            fileInput.addEventListener('change', function(e) {
                const files = e.target.files;
                if (files && files.length > 0) {
                    for (let i = 0; i < files.length; i++) {
                        addFileToSelection(files[i]);
                    }
                    updateFileDisplay();
                }
            });

            // Handle clear all files
            clearAllBtn.addEventListener('click', function() {
                if (selectedFiles.length > 0 && confirm('Remove all selected files?')) {
                    selectedFiles = [];
                    updateFileDisplay();
                }
            });
        }

        // Add a file to the selection
        function addFileToSelection(file) {
            // Check file size
            if (file.size > 10 * 1024 * 1024) {
                alert(`File "${file.name}" is too large (max 10MB). Please choose a smaller file.`);
                return;
            }

            // Check for duplicates (same name and size)
            const isDuplicate = selectedFiles.some(existingFile => 
                existingFile.file.name === file.name && existingFile.file.size === file.size
            );

            if (isDuplicate) {
                alert(`File "${file.name}" is already selected.`);
                return;
            }

            // Create file object with unique ID
            const fileObj = {
                id: ++fileIdCounter,
                file: file,
                preview: null
            };

            // Generate preview for images
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    fileObj.preview = e.target.result;
                    updateFileDisplay(); // Refresh display when preview is ready
                };
                reader.readAsDataURL(file);
            }

            selectedFiles.push(fileObj);
        }

        // Remove a file from selection
        function removeFile(fileId) {
            selectedFiles = selectedFiles.filter(fileObj => fileObj.id !== fileId);
            updateFileDisplay();
        }

        // Update submit button state based on selected files
        function updateSubmitButtonState() {
            const submitBtn = document.querySelector('#reportSwarmForm button[type="submit"]');
            
            // Check if any files are too large (this should not happen due to validation, but double-check)
            let hasInvalidFiles = false;
            for (let i = 0; i < selectedFiles.length; i++) {
                if (selectedFiles[i].file.size > 10 * 1024 * 1024) {
                    hasInvalidFiles = true;
                    break;
                }
            }
            
            // Update submit button state
            if (hasInvalidFiles) {
                submitBtn.disabled = true;
                submitBtn.innerHTML = 'Fix File Issues First';
                submitBtn.className = 'btn btn-warning';
            } else {
                submitBtn.disabled = false;
                submitBtn.innerHTML = 'Submit Report';
                submitBtn.className = 'btn btn-primary';
            }
        }

        // Call updateSubmitButtonState when files change
        function updateFileDisplay() {
            const fileManagementArea = document.getElementById('fileManagementArea');
            const selectedFilesList = document.getElementById('selectedFilesList');
            const totalFileCount = document.getElementById('totalFileCount');

            if (selectedFiles.length === 0) {
                fileManagementArea.style.display = 'none';
                updateSubmitButtonState(); // Update button state
                return;
            }

            fileManagementArea.style.display = 'block';
            totalFileCount.textContent = selectedFiles.length;

            // Generate file list HTML
            let filesHTML = '';
            selectedFiles.forEach(fileObj => {
                const file = fileObj.file;
                const fileSize = (file.size / 1024 / 1024).toFixed(2);
                const isImage = file.type.startsWith('image/');
                const isVideo = file.type.startsWith('video/');
                
                let icon = 'üìÅ';
                let typeClass = 'text-secondary';
                if (isImage) {
                    icon = 'üì∑';
                    typeClass = 'text-primary';
                } else if (isVideo) {
                    icon = 'üé•';
                    typeClass = 'text-info';
                }

                filesHTML += `
                    <div class="file-item mb-3 p-3 border rounded" style="background-color: white;">
                        <div class="d-flex align-items-center">
                            ${fileObj.preview ? 
                                `<img src="${fileObj.preview}" class="file-thumbnail mr-3" style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px; border: 2px solid #dee2e6;">` :
                                `<div class="file-icon mr-3 d-flex align-items-center justify-content-center" style="width: 60px; height: 60px; background: #e9ecef; border-radius: 8px; font-size: 24px;">${icon}</div>`
                            }
                            <div class="flex-grow-1">
                                <div class="${typeClass}">
                                    <strong>${file.name}</strong>
                                </div>
                                <small class="text-muted">
                                    ${fileSize}MB ‚Ä¢ ${file.type || 'Unknown type'}
                                </small>
                            </div>
                            <button type="button" class="btn btn-sm btn-outline-danger ml-2" onclick="removeFile(${fileObj.id})" title="Remove file">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                `;
            });

            selectedFilesList.innerHTML = filesHTML;

            // Show mobile tip if applicable
            if (isMobileDevice() && selectedFiles.length > 0) {
                selectedFilesList.innerHTML += `
                    <div class="alert alert-info p-2 mt-2">
                        <small>üí° Tip: For best results, try taking photos/videos directly in the camera app if upload fails.</small>
                    </div>
                `;
            }
            
            updateSubmitButtonState(); // Update button state
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeFileManagement();
        });

        reportSwarmForm.addEventListener('submit', async function(e) {
            e.preventDefault();
            
            try {
                const submitBtn = document.querySelector('#reportSwarmForm button[type="submit"]');
                const originalBtnText = submitBtn.innerHTML;
                
                console.log('Form submission started, selectedFiles:', selectedFiles);
                
                // Use selected files instead of file input
                const fileCount = selectedFiles.length;
                console.log('File count:', fileCount);
                
                if (fileCount === 0) {
                    if (!confirm('No media files selected. Do you want to continue without photos or videos?')) {
                        return;
                    }
                }
                
                // Check for oversized files (already validated, but double-check)
                let hasOversizedFiles = false;
                for (let i = 0; i < selectedFiles.length; i++) {
                    if (selectedFiles[i].file.size > 10 * 1024 * 1024) {
                        hasOversizedFiles = true;
                        break;
                    }
                }
                
                if (hasOversizedFiles) {
                    alert('Some files are too large (max 10MB each). Please remove them before submitting.');
                    return;
                }
                
                // Create detailed confirmation message
                const description = document.getElementById('description').value;
                const intersection = document.getElementById('intersection').value;
                const reporterName = document.getElementById('reporterName').value;
                const reporterEmail = document.getElementById('reporterEmail').value;
                const reporterPhone = document.getElementById('reporterPhone').value;
                
                let contactText = '';
                if (reporterName || reporterEmail || reporterPhone) {
                    contactText = '\n\nContact Information:\n';
                    if (reporterName) contactText += `Name: ${reporterName}\n`;
                    if (reporterEmail) contactText += `Email: ${reporterEmail}\n`;
                    if (reporterPhone) contactText += `Phone: ${reporterPhone}\n`;
                } else {
                    contactText = '\n\nNo contact information provided.';
                }
                
                let fileListText = '';
                if (fileCount > 0) {
                    fileListText = '\n\nMedia Files:\n';
                    for (let i = 0; i < fileCount; i++) {
                        const file = selectedFiles[i].file;
                        const fileSize = (file.size / 1024 / 1024).toFixed(2);
                        const fileType = file.type.startsWith('image/') ? 'üì∑ Photo' : 
                                       file.type.startsWith('video/') ? 'üé• Video' : 'üìÅ File';
                        fileListText += `${i + 1}. ${fileType}: ${file.name} (${fileSize}MB)\n`;
                    }
                } else {
                    fileListText = '\n\nNo media files selected.';
                }
                
                const confirmMessage = `Please confirm your swarm report:\n\n` +
                                     `üìù Description: ${description}\n` +
                                     `üìç Location: ${intersection}${contactText}${fileListText}\n\n` +
                                     `Submit this report?`;
                
                if (!confirm(confirmMessage)) {
                    return;
                }
                
                // Show loading state
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm mr-2" role="status"></span>Preparing...';
                
                // Create FormData and add selected files manually
                const formData = new FormData(this);
                
                // Add session ID for tracking this user's reports
                formData.append('reporterSessionId', publicUserSessionId);
                
                // Remove any existing media entries from the form
                formData.delete('media');
                
                // Add our selected files
                for (let i = 0; i < selectedFiles.length; i++) {
                    formData.append('media', selectedFiles[i].file);
                }
                
                // Debug logging to verify correct file count
                console.log('FormData created. Selected files count:', selectedFiles.length);
                if (formData.has('media')) {
                    const mediaEntries = formData.getAll('media');
                    console.log('Media entries in FormData:', mediaEntries.length);
                    mediaEntries.forEach((file, index) => {
                        if (file instanceof File) {
                            console.log(`File ${index + 1}: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                        }
                    });
                } else {
                    console.log('No media field found in FormData');
                }
                
                // First, prepare the swarm
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm mr-2" role="status"></span>Validating files...';
                
                const prepareResponse = await fetch('/prepare_swarm', {
                    method: 'POST',
                    body: formData
                });

                if (!prepareResponse.ok) {
                    const errorText = await prepareResponse.text();
                    throw new Error(`Validation failed: ${errorText}`);
                }

                const prepareData = await prepareResponse.json();
                
                // Update UI for upload phase
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm mr-2" role="status"></span>Uploading files...';
                
                // Show upload progress if we have files (with safety check)
                if (fileCount > 0) {
                    const progressMsg = `Uploading ${fileCount} file(s). This may take a moment...`;
                    
                    // Create progress indicator
                    const progressDiv = document.createElement('div');
                    progressDiv.id = 'uploadProgress';
                    progressDiv.className = 'mt-3 p-3 border rounded bg-light';
                    progressDiv.innerHTML = `
                        <div class="text-center">
                            <div class="spinner-border text-primary mb-2" role="status"></div>
                            <div><strong>${progressMsg}</strong></div>
                            <div class="mt-2">
                                <div class="progress">
                                    <div class="progress-bar progress-bar-striped progress-bar-animated" style="width: 100%"></div>
                                </div>
                            </div>
                            <small class="text-muted mt-2 d-block">Please don't close this window or navigate away.</small>
                        </div>
                    `;
                    
                    // Insert progress indicator after the form
                    document.querySelector('.modal-body').appendChild(progressDiv);
                }
                
                // Submit the confirmation with file uploads
                formData.append('referenceID', prepareData.referenceID);
                const confirmResponse = await fetch('/confirm_swarm', {
                    method: 'POST',
                    body: formData
                });

                if (!confirmResponse.ok) {
                    const errorText = await confirmResponse.text();
                    throw new Error(`Upload failed: ${errorText}`);
                }

                const confirmData = await confirmResponse.json();
                console.log('Confirm response data:', confirmData);
                
                // Success! Remove progress indicator
                const progressDiv = document.getElementById('uploadProgress');
                if (progressDiv) {
                    progressDiv.remove();
                }
                
                // Show success message with safe property access
                const uploadedCount = confirmData.reportedMediaURLs ? confirmData.reportedMediaURLs.length : 0;
                const successMessage = `‚úÖ Report submitted successfully!\n\n` +
                                     `Reference ID: ${confirmData.id || 'N/A'}\n` +
                                     `Status: ${confirmData.status || 'Submitted'}\n` +
                                     `Files uploaded: ${uploadedCount}\n\n` +
                                     `Thank you for reporting this swarm! A beekeeper will review your report and respond as soon as possible.`;
                
                alert(successMessage);
                
                // Reset form and UI
                reportSwarmModal.hide();
                reportSwarmForm.reset();
                selectedFiles = []; // Clear selected files array
                updateFileDisplay(); // Update file display
                fetchAndDisplaySwarms(); // Refresh the map
                
            } catch (error) {
                console.error('Form submission error:', error);
                console.error('Error stack:', error.stack);
                
                // Remove progress indicator on error
                const progressDiv = document.getElementById('uploadProgress');
                if (progressDiv) {
                    progressDiv.remove();
                }
                
                let errorMessage = 'Error submitting swarm report: ' + error.message;
                
                // Provide specific guidance based on error type
                if (error.message.includes('Failed to upload file') || error.message.includes('file')) {
                    errorMessage += '\n\nThis might be due to:\n‚Ä¢ File size too large (max 10MB each)\n‚Ä¢ Unsupported file format\n‚Ä¢ Network connection issue\n\nTry using smaller files or a different network.';
                } else if (error.message.includes('Cannot read properties') || error.message.includes('undefined')) {
                    errorMessage += '\n\nThis appears to be a technical issue. Please try again or contact support if the problem persists.';
                    console.error('Detailed error for debugging:', {
                        message: error.message,
                        stack: error.stack,
                        formData: {
                            description: document.getElementById('description').value,
                            intersection: document.getElementById('intersection').value,
                            latitude: document.getElementById('latitude').value,
                            longitude: document.getElementById('longitude').value,
                            fileCount: document.getElementById('media').files ? document.getElementById('media').files.length : 'undefined'
                        }
                    });
                }
                
                alert(errorMessage);
            } finally {
                // Reset button state
                const submitBtn = document.querySelector('#reportSwarmForm button[type="submit"]');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.innerHTML = 'Submit Report';
                }
            }
        });

        // Example of how to call update_swarm_status (for testing/dev purposes)
        // You would build a proper UI for UTBA members for this.
        async function exampleUpdateStatus(reportId, newStatus, notes) {
            try {
                const response = await fetch('/update_swarm_status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ id: reportId, status: newStatus, beekeeperNotes: notes })
                });
                if (response.ok) {
                    const updatedReport = await response.json();
                    console.log("Update successful:", updatedReport);
                    fetchAndDisplaySwarms(); // Refresh map
                } else {
                    const errorText = await response.text();
                    console.error("Failed to update status:", errorText);
                    alert("Failed to update status: " + errorText);
                }
            } catch (error) {
                console.error("Error updating status:", error);
            }
        }
        // To test: find a report ID from console after submitting, then call:
        // exampleUpdateStatus("1", "Captured", "Successfully collected the swarm.");

        // Add refresh button functionality
        refreshMapBtn.addEventListener('click', function() {
            console.log('Refresh button clicked - clearing all markers first');
            // Clear all existing markers
            reportedSwarmMarkers.forEach((marker, id) => {
                console.log('Removing marker:', id);
                map.removeLayer(marker);
            });
            reportedSwarmMarkers.clear();
            console.log('All markers cleared, fetching fresh data...');
            fetchAndDisplaySwarms();
        });

        // Modal reset handler
        $('#reportSwarmModal').on('hidden.bs.modal', function() {
            // Clean up file selection and reset form state
            selectedFiles = [];
            updateFileDisplay();
            document.getElementById('media').value = '';
            
            // Remove any upload progress indicators
            const progressDiv = document.getElementById('uploadProgress');
            if (progressDiv) {
                progressDiv.remove();
            }
            
            // Reset submit button
            const submitBtn = document.querySelector('#reportSwarmForm button[type="submit"]');
            submitBtn.disabled = false;
            submitBtn.innerHTML = 'Submit Report';
            submitBtn.className = 'btn btn-primary';
        });
    </script>

    <!-- Privacy Notice -->
    <div class="container-fluid mt-4">
        <div class="row">
            <div class="col-md-12">
                <div class="card">
                    <div class="card-body py-2">
                        <h6 class="card-title mb-2">üîí Privacy & Data Notice</h6>
                        <p class="small mb-0 text-muted">
                            <strong>Minimal data collection:</strong> Swarm reports only include location, description, and optional photos/videos. 
                            No personal identifying information is required or stored. This application is hosted on Google Cloud infrastructure 
                            in Montreal, Canada. Your location data is only used to place swarm markers on the map and is not linked to personal identifiers. 
                            Contact information provided is optional and used solely for swarm collection coordination.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add a footer with version -->
    <footer style="text-align: center; margin-top: 20px; font-size: 0.8em; color: #ffffff;">
        Version: {{.Version}}
    </footer>
</body>
</html> 